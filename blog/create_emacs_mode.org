#+title: Création d'un mode emacs (efetch).
#+startup: indent

* Intro

Bonjour à tous. Vous connaissez peut-être =neofetch=, cette commande
qui permet d'avoir des informations sur le système avec un affichage
plutôt sympa.

#+CAPTION: Neofetch sous GuixSD
#+NAME: neofetch
[[./neofetch.png]]

Je me suis dit qu'une version Emacs ne serais pas une mauvaise
idée. Comme j'avais un peu de temps ce weekend je me suis mis au
travail. Et voila le projet =eftech= qui est lancer, le dépôt Git est
créé [[https://framagit.org/prouby/emacs-fetch]], reste plus qu'a écrire
du code !

* Le code

Problème, hormis ma configuration Emacs je n'ai jamais écrie de code
en emacs lisp... J'ai déjà eu l'occasion de coder en GNU Guile ou en
Ocaml donc le paradigme fonctionnel ne me pose pas particulièrement de
problème. Par contre je me dis qu'un tuto elisp, pour la gestion des
buffers en emacs lisp par exemple, pourrai mettre utile.

Très vite je tombe sur ce site web plutôt bien fait :
[[http://ergoemacs.org/emacs/elisp.html]], qui contient toutes les infos
dont j'ai besoin.

Il faut encore réfléchir à comment récupérer les informations sur le
système. Pour les infos sur l'OS il y a la commande =lsb_release=,
mais je suis actuellement sur un =GuixSD= qui n'utilise pas
=lsb_release= comme de nombreux système GNU/Linux. La méthode de
détection de l'OS n'est donc pas la même en fonction du système sur le
quelle on est.

Voici une fonction qui permet de récupérer le nom et la version du
système. Pour le moment elle détecte les OS qui utilise =lsb_release=
ou =guix=, il faudra ajouter des méthodes supplémentaires pour les
autres systèmes dans le futur.

#+BEGIN_SRC emacs-lisp
(defun ef-distro ()
  "Return operation system name and version."
  (cond
   ;; lsb_release
   ((eq (shell-command "type -p lsb_release") 0)
    (shell-command-to-string "lsb_release -sd"))
   ;; Guix
   ((eq (shell-command "type -p guix") 0)
    (concat "GuixSD "
            (nth 4 (split-string
                    (shell-command-to-string
                     "guix system -V")
                    " \\|\n"))))
   ;; Default
   (t "Unknown OS")))
#+END_SRC

Pour les informations sur le noyau, la commande =uname= permet
d'accéder a toutes les informations dont nous avons besoins. Je crée
une fonction supplémentaire.

#+BEGIN_SRC emacs-lisp
(defun ef-uname (opt)
  "Exec uname with 'opt' and return the first line of command
output."
  (car (split-string
        (shell-command-to-string (format "uname %s" opt))
        "\n")))
#+END_SRC

Pour le =shell= je vais au plus simple et j'utilise la variable
d'environement =SHELL=. Pour les informations sur Emacs j'utilise les
function =emacs-version= et =emacs-uptime=.

Il manque encore une chose ou deux, notamment un mode ! Pas besoin de
faire compliquer je fais seulement un peu de coloration syntaxique.

#+BEGIN_SRC emacs-lisp
(setq efetch-highlights
      '(("\\(.*\\) :" . font-lock-function-name-face)
        ("Efetch"     . font-lock-constant-face)))

(define-derived-mode efetch-mode fundamental-mode "efetch"
  "Major mode for displaying efetch buffer."
  (setq font-lock-defaults '(efetch-highlights)))
#+END_SRC

Reste plus cas écrire la fonction principale =efetch= dont la recette
de cuisine pourrait se simplifier comme ceci :
 - Créer un nouveau buffer
 - Récupérer les infos
 - Activer le mode =efetch=
 - Insérer les infos

Je rajoute une image, fix pour le moment on pourrait la remplacer par
le logo de l'OS dans le futur. Je mets aussi le buffer en lecture seul
par défaut.

#+BEGIN_SRC emacs-lisp
(defun efetch ()
  "Display emacs and system configuration in new buffer."
  (interactive)
  (let* ((buff  (generate-new-buffer "efetch"))
         (data  `(("OS"     . ,(ef-distro))
                  ("Host"   . ,(system-name))
                  ("Kernel" . ,(ef-uname "-s"))
                  ("Kernel version" . ,(ef-uname "-r"))
                  ("Arch"   . ,(ef-uname "-m"))
                  ("Shell"  . ,(ef-shell))
                  ("Emacs"  . ,(ef-emacs-info))
                  ("Emacs uptime" . ,(emacs-uptime)))))
    ;; Switch to new buffer and active efetch-mode
    (set-buffer buff)
    (switch-to-buffer buff)
    (efetch-mode)

    ;; Insert data
    (insert "+++ Efetch +++\n")

    (insert-image
     (create-image (concat ef-images-dir "/default.png")))
    (insert "\n")

    (mapc 'ef-display data)

    ;; Set buffer to read only mode
    (read-only-mode)))
#+END_SRC

* Le resultat

Et voila le résultat !

#+CAPTION: Efetch sous Emacs 26 avec le thème Tango
#+NAME: efetch
[[./efetch_01.png]]

* Le Makefile

Voici sans doute le =Makefile= le plus complexe que j'ai jamais écrie
jusque la. /Je plains la personne qui va vouloir le relire !/

Déjà il utilise un certain nombre de variables :

#+BEGIN_SRC makefile
EMACS = emacs -Q -q --batch -nw
EMACS_LOAD = -l efetch-mode.el
EMACS_COMPILE = -f emacs-lisp-byte-compile
EMACS_DIR = ~/.emacs.d/efetch-mode/
EMACS_DEFAULT_CONF = ~/.emacs
EMACS_PAYLOAD = efetch-payload.txt

IMAGES_DIR = images/
INST_IMAGES_DIR = $(EMACS_DIR)$(IMAGES_DIR)

SED_SOURCES = $(wildcard *.el.in)

SOURCES = $(wildcard *.el)
SOURCES += $(SED_SOURCES:.el.in=.el)

COMPILED_FILE += $(SOURCES:.el=.elc)
#+END_SRC

Des règles de compilation générique :

#+BEGIN_SRC makefile
%.elc: %.el
	$(info Compiling    $@)
	@$(EMACS) $(EMACS_LOAD) $< $(EMACS_COMPILE)

%.el: %.el.in
	$(info Sed          $@)
	@sed 's|@INST_IMAGES_DIR@|$(INST_IMAGES_DIR)|' < $< >$@

%.txt: %.in
	$(info Sed          $@)
	@sed 's|@EMACS_DIR@|$(EMACS_DIR)|' < $< >$@
#+END_SRC

Et des instructions de compilation =compile=, installation =install=,
dé-installation =uninstall= et mise à jour =upgrade=.

Pour l'installation une charge utile et écrite dans le fichier
=~/.emacs=. Cette charge utile permet d'ajouter du code capable de
charger le mode au démarrage d'Emacs.

#+BEGIN_SRC makefile
payload:
	$(info Payload)
	@cat $(EMACS_PAYLOAD) >> $(EMACS_DEFAULT_CONF)
#+END_SRC

Il est donc possible d'installer le mode avec la commande =make
install=, puis de le mettre à jours en fessant un =git pull= suivi
d'un =make upgrade=.

* La suite

Pour la suite du projet il faut penser à ajouter des fonctionnalités
(logo de la distrib, plus d'information sur le système, etc.), et
prendre en charge plus de système d'exploitation.

Mais le projet manque aussi cruellement de documentation, à l'heure ou
j'écris ces mots il n'y a pas encore de =README= dans le projet.

De plus il serait intéressant de créer un paquet Guix pour son
installation.
